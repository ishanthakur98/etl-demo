# ====================================
# 1. SPRING BATCH CONFIGURATION
# ====================================

# ? CRITICAL: Disable the auto-runner so the JobScheduler takes control.
spring.batch.job.enabled=true

# Spring Batch execution properties
spring.batch.initialize-schema=always
job.import-users.cron=0 7 17 * * * # Cron expression for other jobs (keep the original schedules for context)
job.process-data.cron=0 0 * * * *
job.report-gen.cron=0 0 17 ? * SUN

# ====================================
# 2. DATA SOURCE (JOB REPOSITORY)
# ====================================
#spring.datasource.url=jdbc:h2:mem:batchdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
#spring.datasource.driverClassName=org.h2.Driver
#spring.datasource.username=sa
#spring.datasource.password=password

# ====================================
# 3. SCHEDULING CONFIGURATION
# ====================================

# Configure the thread pool for the scheduler service (@Scheduled methods).
#spring.task.scheduling.pool.size=5


# ====================================
# 2. DATA SOURCE (POSTGRESQL REPOSITORY)
# ====================================
spring.datasource.url=jdbc:postgresql://postgres-service:5432/batchdb
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.username=batchuser
# Password injected via K8s Secret
# ...

# ====================================
# 5. POSTGRESQL DIALECT AND JPA/HIBERNATE SETTINGS
# ====================================

# ? Explicitly set the dialect for PostgreSQL
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Show the SQL generated by Hibernate (Optional, useful for debugging)
spring.jpa.show-sql=false

# Configure Schema Management (DTD) for application data (if you use JPA entities)
# If your application uses JPA/Hibernate to manage application tables (like the 'user' table),
# this tells Hibernate what to do on startup.
# Options: none, update, create, create-drop
spring.jpa.hibernate.ddl-auto=none